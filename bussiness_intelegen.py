# -*- coding: utf-8 -*-
"""Bussiness intelegen.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15PnxZv7b_98H33bO1_LHlUgUk8c-8pZy

# Install libraries
"""

!pip install pytorch-forecasting lightning pandas numpy yfinance ta bokeh scikit-learn statsmodels tensorflow -q

import pandas as pd
import numpy as np
import yfinance as yf
import warnings
warnings.filterwarnings('ignore')

from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.statespace.sarimax import SARIMAX

"""# Deep Learning Models"""

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from tensorflow.keras.callbacks import EarlyStopping
from sklearn.preprocessing import MinMaxScaler

"""# PyTorch dan TFT"""

import torch
from pytorch_forecasting import TimeSeriesDataSet, TemporalFusionTransformer
from pytorch_forecasting.data import GroupNormalizer
from pytorch_forecasting.metrics import QuantileLoss
from lightning.pytorch import Trainer
from lightning.pytorch.callbacks import EarlyStopping as PLEarlyStopping

"""# Visualisasi dengan Bokeh"""

from bokeh.plotting import figure, show, output_notebook
from bokeh.layouts import column, row, gridplot
from bokeh.models import HoverTool, Legend
from bokeh.palettes import Category10

"""# Technical Analysis"""

import ta

from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

"""# Load Data Saham BBRI"""

import yfinance as yf
import pandas as pd

ticker_symbol= "BBRI.JK"

start_date = "2010-01-01"
end_date = "2025-11-01"

df = yf.download(ticker_symbol, start=start_date, end=end_date)
df.reset_index(inplace=True)

# Flatten MultiIndex columns if they exist
if isinstance(df.columns, pd.MultiIndex):
    # This creates names like 'Open', 'High', 'Low', 'Close', 'Adj Close', 'Volume', 'Date'
    # if it's from a single ticker and Price/Ticker levels
    # For a single ticker, the structure is usually (Level 0, Level 1) where Level 0 is 'Price' and Level 1 is actual column name.
    # 'Date' column is usually top level.
    df.columns = [col[1] if col[0] == 'Price' else col[0] for col in df.columns.values]

# Rename 'Date' to 'date' and convert all others to lowercase
new_columns = []
for col in df.columns:
    if col == 'Date':
        new_columns.append('date')
    else:
        new_columns.append(col.lower().replace(' ', '_'))
df.columns = new_columns

# Ensure only desired columns are kept and in a standard order
# This assumes 'adj_close' might be present but 'close' is what's used for MA.
# We are making sure 'close' exists and removing 'adj_close' for simplicity if it's not needed.
cols_to_keep = ['date', 'open', 'high', 'low', 'close', 'volume']
df = df[[col for col in cols_to_keep if col in df.columns]].copy()

(df)

"""# MENGHITUNG INDIKATOR TEKNIKAL"""

# Moving Average (MA) 7 dan 30 hari
df['ma_7'] = df['close'].rolling(window=7).mean()
df['ma_30'] = df['close'].rolling(window=30).mean()

"""Relative Strength Index (RSI)"""

df['rsi'] = ta.momentum.RSIIndicator(close=df['close'], window=14).rsi()

"""MACD dan Signal Line"""

macd = ta.trend.MACD(close=df['close'])
df['macd'] = macd.macd()
df['macd_signal'] = macd.macd_signal()
df['macd_diff'] = macd.macd_diff()

"""Bollinger Bands"""

bollinger = ta.volatility.BollingerBands(close=df['close'], window=20, window_dev=2)
df['bb_upper'] = bollinger.bollinger_hband()
df['bb_middle'] = bollinger.bollinger_mavg()
df['bb_lower'] = bollinger.bollinger_lband()
df['bb_width'] = bollinger.bollinger_wband()

"""Volume features"""

df['volume_ma_7'] = df['volume'].rolling(window=7).mean()

"""Price changes"""

df['returns'] = df['close'].pct_change()
df['price_change'] = df['close'].diff()

"""Remove NaN values"""

df = df.dropna().reset_index(drop=True)

train_size = int(len(df) * 0.8)
test_size = len(df) - train_size

train_df = df[:train_size].copy()
test_df = df[train_size:].copy()

print(f"âœ“ Data split selesai")
print(f"  - Training: {len(train_df)} baris ({train_size/len(df)*100:.1f}%)")
print(f"  - Testing: {len(test_df)} baris ({test_size/len(df)*100:.1f}%)")

"""# SPLIT DATA

ARIMA
"""

# ARIMA hanya menggunakan data univariate (close price)
train_close = train_df['close'].values

# Fit ARIMA model (p=5, d=1, q=2)
arima_model = ARIMA(train_close, order=(5, 1, 2))
arima_fitted = arima_model.fit()

# Predict
arima_predictions = arima_fitted.forecast(steps=test_size)

print("âœ“ ARIMA Model berhasil dilatih")
print(f"  - Order: (5, 1, 2)")
print(f"  - AIC: {arima_fitted.aic:.2f}")

"""SARIMAX"""

# SARIMAX dengan exogenous variables (indikator teknikal)
exog_features = ['ma_7', 'ma_30', 'rsi', 'macd', 'volume_ma_7']
train_exog = train_df[exog_features].values
test_exog = test_df[exog_features].values

# Fit SARIMAX model
sarimax_model = SARIMAX(
    train_close,
    exog=train_exog,
    order=(5, 1, 2),
    seasonal_order=(1, 1, 1, 12),
    enforce_stationarity=False,
    enforce_invertibility=False
)
sarimax_fitted = sarimax_model.fit(disp=False)
sarimax_predictions = sarimax_fitted.forecast(steps=test_size, exog=test_exog)

print("âœ“ SARIMAX Model berhasil dilatih")
print(f"  - Order: (5, 1, 2)")
print(f"  - Seasonal Order: (1, 1, 1, 12)")
print(f"  - AIC: {sarimax_fitted.aic:.2f}")

"""LSTM"""

# Prepare data for LSTM
lstm_features = ['close', 'open', 'high', 'low', 'volume',
                 'ma_7', 'ma_30', 'rsi', 'macd', 'macd_signal',
                 'bb_upper', 'bb_middle', 'bb_lower']

# Scale data
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(df[lstm_features].values)

# Create sequences
def create_sequences(data, seq_length):
    X, y = [], []
    for i in range(len(data) - seq_length):
        X.append(data[i:i+seq_length])
        y.append(data[i+seq_length, 0])  # Predict close price
    return np.array(X), np.array(y)

seq_length = 60
X, y = create_sequences(scaled_data, seq_length)

# Split
train_size_lstm = int(len(X) * 0.8)
X_train, X_test = X[:train_size_lstm], X[train_size_lstm:]
y_train, y_test = y[:train_size_lstm], y[train_size_lstm:]

# Build LSTM model
lstm_model = Sequential([
    LSTM(100, return_sequences=True, input_shape=(seq_length, len(lstm_features))),
    Dropout(0.2),
    LSTM(100, return_sequences=True),
    Dropout(0.2),
    LSTM(50, return_sequences=False),
    Dropout(0.2),
    Dense(25),
    Dense(1)
])

lstm_model.compile(optimizer='adam', loss='mean_squared_error')

# Train
early_stop = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)
history = lstm_model.fit(
    X_train, y_train,
    epochs=50,
    batch_size=32,
    validation_split=0.1,
    callbacks=[early_stop],
    verbose=0
)

# Predict
lstm_predictions_scaled = lstm_model.predict(X_test, verbose=0)

# Inverse transform
lstm_predictions_full = np.zeros((len(lstm_predictions_scaled), len(lstm_features)))
lstm_predictions_full[:, 0] = lstm_predictions_scaled.flatten()
lstm_predictions = scaler.inverse_transform(lstm_predictions_full)[:, 0]

print("âœ“ LSTM Model berhasil dilatih")
print(f"  - Architecture: 3 LSTM layers (100, 100, 50 units)")
print(f"  - Sequence Length: {seq_length}")
print(f"  - Epochs: {len(history.history['loss'])}")

"""# Temporal Fusion Transformer"""

# Prepare data for TFT
df_tft = df.copy()
df_tft['time_idx'] = range(len(df_tft))
df_tft['series'] = 'BBRI'
df_tft['target'] = df_tft['close']

train_tft = df_tft[:train_size].copy()
test_tft = df_tft[train_size:].copy()

# Define parameters
max_prediction_length = min(30, test_size)
max_encoder_length = 60

# Create TimeSeriesDataSet
training_tft = TimeSeriesDataSet(
    train_tft,
    time_idx="time_idx",
    target="target",
    group_ids=["series"],
    min_encoder_length=max_encoder_length // 2,
    max_encoder_length=max_encoder_length,
    min_prediction_length=1,
    max_prediction_length=max_prediction_length,
    static_categoricals=["series"],
    time_varying_known_reals=["time_idx"],
    time_varying_unknown_reals=[
        "target", "open", "high", "low", "volume",
        "ma_7", "ma_30", "rsi", "macd", "macd_signal",
        "bb_upper", "bb_middle", "bb_lower"
    ],
    target_normalizer=GroupNormalizer(groups=["series"], transformation="softplus"),
    add_relative_time_idx=True,
    add_target_scales=True,
    add_encoder_length=True,
)

validation_tft = TimeSeriesDataSet.from_dataset(training_tft, test_tft, predict=True, stop_randomization=True)

# Dataloaders
batch_size = 32
train_dataloader = training_tft.to_dataloader(train=True, batch_size=batch_size, num_workers=0)
val_dataloader = validation_tft.to_dataloader(train=False, batch_size=batch_size, num_workers=0)

# TFT model
tft = TemporalFusionTransformer.from_dataset(
    training_tft,
    learning_rate=0.03,
    hidden_size=32,
    attention_head_size=2,
    dropout=0.1,
    hidden_continuous_size=16,
    output_size=7,
    loss=QuantileLoss(),
    reduce_on_plateau_patience=4,
)

# Trainer
early_stop_tft = PLEarlyStopping(monitor="val_loss", min_delta=1e-4, patience=10, verbose=False, mode="min")
trainer = Trainer(
    max_epochs=30,
    accelerator="auto",
    gradient_clip_val=0.1,
    callbacks=[early_stop_tft],
    logger=False,
    enable_checkpointing=False,
    enable_model_summary=False,
)

# Train
trainer.fit(tft, train_dataloaders=train_dataloader, val_dataloaders=val_dataloader)

# Predict
tft_predictions_raw = tft.predict(val_dataloader, mode="prediction", return_x=True)
tft_predictions = tft_predictions_raw[0].numpy()

print("âœ“ TFT Model berhasil dilatih")
print(f"  - Hidden size: 32")
print(f"  - Attention heads: 2")
print(f"  - Max encoder length: {max_encoder_length}")

"""# EVALUASI SEMUA MODEL"""

actual_values = test_df['close'].values

# Adjust predictions to match test size
arima_pred = arima_predictions[:len(actual_values)]
sarimax_pred = sarimax_predictions[:len(actual_values)]

# LSTM predictions (align with test data)
lstm_pred = lstm_predictions[:len(actual_values)]
if len(lstm_pred) < len(actual_values):
    lstm_pred = np.pad(lstm_pred, (0, len(actual_values) - len(lstm_pred)), 'edge')
elif len(lstm_pred) > len(actual_values):
    lstm_pred = lstm_pred[:len(actual_values)]

# TFT predictions
# tft_predictions (Variable #23) has shape (1, 30), representing a single forecast horizon.
# Flatten it to a 1D array.
tft_pred_flat = tft_predictions.flatten() # Shape (30,)

# For evaluation, compare the predicted horizon with the actual values in that same horizon.
# Slice actual_values to match the length of the TFT forecast.
actual_tft_horizon = actual_values[:len(tft_pred_flat)] # Shape (30,)

# Calculate metrics for each model
def calculate_metrics(actual, predicted, model_name):
    mae = mean_absolute_error(actual, predicted)
    rmse = np.sqrt(mean_squared_error(actual, predicted))
    mape = np.mean(np.abs((actual - predicted) / actual)) * 100
    r2 = r2_score(actual, predicted)

    print(f"\n{model_name}:")
    print(f"  MAE:  {mae:>10.2f}")
    print(f"  RMSE: {rmse:>10.2f}")
    print(f"  MAPE: {mape:>9.2f}%")
    print(f"  RÂ²:   {r2:>10.4f}")

    return {'MAE': mae, 'RMSE': rmse, 'MAPE': mape, 'R2': r2}

metrics = {}
metrics['ARIMA'] = calculate_metrics(actual_values, arima_pred, "ARIMA")
metrics['SARIMAX'] = calculate_metrics(actual_values, sarimax_pred, "SARIMAX")
metrics['LSTM'] = calculate_metrics(actual_values, lstm_pred, "LSTM")
# Use the correctly shaped TFT predictions and actual values for metric calculation
metrics['TFT'] = calculate_metrics(actual_tft_horizon, tft_pred_flat, "TFT")

# Find best model
best_model = min(metrics.items(), key=lambda x: x[1]['RMSE'])
print(f"\n{'='*80}")
print(f"ðŸ† MODEL TERBAIK: {best_model[0]} (RMSE terendah: {best_model[1]['RMSE']:.2f})")
print(f"{'='*80}")

"""# VISUALISASI"""

output_notebook()

# Prepare dates
test_dates = test_df['date'].values[:len(actual_values)]

# Plot 1: Perbandingan Semua Model
p1 = figure(
    title="Perbandingan Prediksi: ARIMA vs SARIMAX vs LSTM vs TFT",
    x_axis_type='datetime',
    width=1200,
    height=500,
    tools="pan,wheel_zoom,box_zoom,reset,save"
)

p1.line(train_df['date'], train_df['close'], legend_label="Training Data",
        line_width=2, color='gray', alpha=0.5)
p1.line(test_dates, actual_values, legend_label="Actual",
        line_width=3, color='black')
p1.line(test_dates, arima_pred, legend_label="ARIMA",
        line_width=2, color='red', line_dash='dashed')
p1.line(test_dates, sarimax_pred, legend_label="SARIMAX",
        line_width=2, color='blue', line_dash='dotted')
p1.line(test_dates, lstm_pred, legend_label="LSTM",
        line_width=2, color='green', line_dash='dashdot')

# Use tft_pred_flat (1D) and slice test_dates to match its length for plotting
p1.line(test_dates[:len(tft_pred_flat)], tft_pred_flat, legend_label="TFT",
        line_width=2, color='purple', alpha=0.8)

p1.legend.location = "top_left"
p1.legend.click_policy = "hide"
p1.xaxis.axis_label = "Tanggal"
p1.yaxis.axis_label = "Harga (IDR)"

p2 = figure(
    title="Relative Strength Index (RSI)",
    x_axis_type='datetime',
    width=1200,
    height=300,
    tools="pan,wheel_zoom,box_zoom,reset,save"
)

p2.line(df['date'], df['rsi'], legend_label="RSI", line_width=2, color='blue')
p2.line(df['date'], [70]*len(df), legend_label="Overbought",
        line_width=1.5, color='red', line_dash='dashed')
p2.line(df['date'], [30]*len(df), legend_label="Oversold",
        line_width=1.5, color='green', line_dash='dashed')

p2.legend.location = "top_left"
p2.xaxis.axis_label = "Tanggal"
p2.yaxis.axis_label = "RSI"

p3 = figure(
    title="MACD dan Signal Line",
    x_axis_type='datetime',
    width=1200,
    height=300,
    tools="pan,wheel_zoom,box_zoom,reset,save"
)

p3.line(df['date'], df['macd'], legend_label="MACD", line_width=2, color='blue')
p3.line(df['date'], df['macd_signal'], legend_label="Signal",
        line_width=2, color='red')
p3.vbar(x=df['date'], top=df['macd_diff'], width=0.8,
        legend_label="Histogram", color='gray', alpha=0.5)

p3.legend.location = "top_left"
p3.xaxis.axis_label = "Tanggal"
p3.yaxis.axis_label = "MACD"

p4 = figure(
    title="Bollinger Bands dengan Harga Saham",
    x_axis_type='datetime',
    width=1200,
    height=400,
    tools="pan,wheel_zoom,box_zoom,reset,save"
)

p4.line(df['date'], df['close'], legend_label="Harga",
        line_width=2, color='navy')
p4.line(df['date'], df['bb_upper'], legend_label="Upper Band",
        line_width=1.5, color='red', line_dash='dashed', alpha=0.7)
p4.line(df['date'], df['bb_middle'], legend_label="Middle Band",
        line_width=1.5, color='orange', alpha=0.7)
p4.line(df['date'], df['bb_lower'], legend_label="Lower Band",
        line_width=1.5, color='green', line_dash='dashed', alpha=0.7)

p4.varea(x=df['date'], y1=df['bb_lower'], y2=df['bb_upper'],
         alpha=0.1, color='blue')

p4.legend.location = "top_left"
p4.xaxis.axis_label = "Tanggal"
p4.yaxis.axis_label = "Harga (IDR)"

layout = column(p1, p2, p3, p4)
show(layout)

print("\n" + "=" * 80)
print("ANALISIS TEKNIKAL TERAKHIR")
print("=" * 80)

latest = df.iloc[-1]
print(f"\nData Terakhir ({latest['date'].strftime('%Y-%m-%d')}):")
print(f"  Harga Penutupan: Rp {latest['close']:>12,.0f}")
print(f"  MA 7 hari:       Rp {latest['ma_7']:>12,.0f}")
print(f"  MA 30 hari:      Rp {latest['ma_30']:>12,.0f}")
print(f"  RSI:             {latest['rsi']:>15.2f}")
print(f"  MACD:            {latest['macd']:>15.4f}")
print(f"  MACD Signal:     {latest['macd_signal']:>15.4f}")
print(f"  BB Upper:        Rp {latest['bb_upper']:>12,.0f}")
print(f"  BB Lower:        Rp {latest['bb_lower']:>12,.0f}")

print("\n" + "-" * 80)
print("INTERPRETASI SINYAL:")
print("-" * 80)

if latest['rsi'] > 70:
    print("  ðŸ”´ RSI > 70: OVERBOUGHT - Potensi koreksi/penurunan")
elif latest['rsi'] < 30:
    print("  ðŸŸ¢ RSI < 30: OVERSOLD - Peluang beli")
else:
    print("  ðŸŸ¡ RSI 30-70: Neutral/Normal")

# Moving Average Analysis
if latest['close'] > latest['ma_7'] > latest['ma_30']:
    print("  ðŸŸ¢ MA: Strong Bullish Trend (Harga > MA7 > MA30)")
elif latest['close'] < latest['ma_7'] < latest['ma_30']:
    print("  ðŸ”´ MA: Strong Bearish Trend (Harga < MA7 < MA30)")
else:
    print("  ðŸŸ¡ MA: Mixed Signals")

# MACD Analysis
if latest['macd'] > latest['macd_signal']:
    print("  ðŸŸ¢ MACD > Signal: Momentum Positif")
else:
    print("  ðŸ”´ MACD < Signal: Momentum Negatif")

# Bollinger Bands Analysis
if latest['close'] > latest['bb_upper']:
    print("  ðŸ”´ Harga > Upper Band: Overbought territory")
elif latest['close'] < latest['bb_lower']:
    print("  ðŸŸ¢ Harga < Lower Band: Oversold territory")
else:
    print("  ðŸŸ¡ Harga dalam Bollinger Bands: Normal range")

print("\n" + "=" * 80)
print("KESIMPULAN:")
print("=" * 80)
print(f"âœ“ Model terbaik untuk prediksi: {best_model[0]}")
print(f"âœ“ RMSE terbaik: {best_model[1]['RMSE']:.2f}")
print(f"âœ“ MAPE terbaik: {best_model[1]['MAPE']:.2f}%")

"""### Menyimpan Model Terbaik untuk Deployment"""

import torch

# Dapatkan nama model terbaik dari hasil evaluasi sebelumnya
best_model_name = best_model[0]

if best_model_name == 'TFT':
    model_to_save = tft # 'tft' adalah objek model TemporalFusionTransformer yang sudah dilatih
    model_path = 'best_tft_model.pth'
    torch.save(model_to_save.state_dict(), model_path)
    print(f"âœ“ Model {best_model_name} berhasil disimpan ke {model_path}")
elif best_model_name == 'LSTM':
    model_to_save = lstm_model # 'lstm_model' adalah objek model Keras LSTM
    model_path = 'best_lstm_model.h5'
    model_to_save.save(model_path)
    print(f"âœ“ Model {best_model_name} berhasil disimpan ke {model_path}")
elif best_model_name == 'ARIMA':
    model_to_save = arima_fitted # 'arima_fitted' adalah objek model ARIMA yang sudah dilatih
    model_path = 'best_arima_model.pkl'
    import joblib
    joblib.dump(model_to_save, model_path)
    print(f"âœ“ Model {best_model_name} berhasil disimpan ke {model_path}")
elif best_model_name == 'SARIMAX':
    model_to_save = sarimax_fitted # 'sarimax_fitted' adalah objek model SARIMAX yang sudah dilatih
    model_path = 'best_sarimax_model.pkl'
    import joblib
    joblib.dump(model_to_save, model_path)
    print(f"âœ“ Model {best_model_name} berhasil disimpan ke {model_path}")
else:
    print(f"âš ï¸ Tidak dapat menyimpan model: {best_model_name} tidak dikenali atau tidak ada strategi penyimpanan yang ditentukan.")